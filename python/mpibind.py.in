""" Implements an interface around the mpibind C library.

This module implements a python interface around the mpibind C API.
This documentation describes specifics about the python interface.

Unsupported Functions:


hwloc_bitmap_t* mpibind_get_gpus(mpibind_t *handle);
hwloc_bitmap_t* mpibind_get_cpus(mpibind_t *handle);
# translate to python object (bitmap or list)

hwloc_topology_t mpibind_get_topology(mpibind_t *handle); 
int mpibind_set_topology(mpibind_t *handle,
			   hwloc_topology_t topo); (comparable functionality supported through xml file)

TODO How do we apply the mappings generated by mpibind
"""

import os
import re
from cffi import FFI

LONG_STR_SIZE = 1024

_ffi = FFI()

# data and fucntion prototypes
_ffi.cdef('''
  enum { 
    /* Caller can restrict the topology based on CPU or MEM */
    MPIBIND_RESTRICT_CPU,
    MPIBIND_RESTRICT_MEM,

    /* Type of I/O ID */ 
    MPIBIND_ID_UNIV, 
    MPIBIND_ID_VISDEVS,
    MPIBIND_ID_PCIBUS,
    MPIBIND_ID_NAME,
  }; 

  struct mpibind_t; 
  typedef struct mpibind_t mpibind_t;

  int mpibind_init(mpibind_t **handle);
  int mpibind_finalize(mpibind_t *handle); 
  int mpibind(mpibind_t *handle);

  int mpibind_set_ntasks(mpibind_t *handle,
	      int ntasks);
  int mpibind_set_nthreads(mpibind_t *handle,
	      int nthreads);
  int mpibind_set_greedy(mpibind_t *handle,
	      int greedy);
  int mpibind_set_gpu_optim(mpibind_t *handle,
			  int gpu_optim);
  int mpibind_set_smt(mpibind_t *handle,
		    int smt);
  int mpibind_set_restrict_ids(mpibind_t *handle,
			  char *restr_set);
  int mpibind_set_restrict_type(mpibind_t *handle,
				int restr_type);

  int mpibind_get_ntasks(mpibind_t *handle);
  int* mpibind_get_nthreads(mpibind_t *handle);
  int mpibind_get_greedy(mpibind_t *handle);
  int mpibind_get_gpu_optim(mpibind_t *handle);
  int mpibind_get_smt(mpibind_t *handle);
  char* mpibind_get_restrict_ids(mpibind_t *handle);
  int mpibind_get_restrict_type(mpibind_t *handle);

  char** mpibind_get_gpus_ptask(mpibind_t *handle, 
          int taskid, int *ngpus);

  void mpibind_mapping_print(mpibind_t *handle);
  int mpibind_mapping_ptask_snprint(char *buf, size_t size, 
        mpibind_t *handle, int taskid);
  int mpibind_mapping_snprint(char *str, size_t size,
        mpibind_t *handle);
  int mpibind_set_gpu_ids(mpibind_t *handle, 
        int id_type);

  int mpibind_set_env_vars(mpibind_t *handle);
  void mpibind_env_vars_print(mpibind_t *handle);  
  char** mpibind_get_env_var_values(mpibind_t *handle,
				    char *name);
  char** mpibind_get_env_var_names(mpibind_t *handle, int *count);

''')

_libmpibind = _ffi.dlopen('@mpibindlib@')

def topology_set_xml(topology_file_path):
    """
    Set the HWLOC_XMLFILE that mpibind uses for its topology

    :param topology_file_path: The file path of a hwloc topology XML file
    :type topology_file_path: string
    """
    os.environ["HWLOC_XMLFILE"] = topology_file_path

class MpibindHandle():
    def __init__(self):
        self.__phandle = _ffi.new("struct mpibind_t **")
        rc = _libmpibind.mpibind_init(self.__phandle)
        if rc != 0:
            raise RuntimeError("mpibind_init failed")
        self.__handle = self.__phandle[0]

    def finalize(self):
        rc = _libmpibind.mpibind_finalize(self.__handle)
        if rc != 0:
            raise RuntimeError("mpibind_finalize failed")

    def mpibind(self):
        rc = _libmpibind.mpibind(self.__handle)
        if rc != 0:
            raise RuntimeError("mpibind failed")

    def mapping_print(self):
        _libmpibind.mpibind_mapping_print(self.__handle)

    @property
    def ntasks(self):
        return _libmpibind.mpibind_get_ntasks(self.__handle)

    @ntasks.setter
    def ntasks(self, var):
        rc = _libmpibind.mpibind_set_ntasks(self.__handle, var)
        if rc != 0:
            raise RuntimeError("mpibind_set_ntasks failed")

    @property
    def nthreads(self):
        raw = _libmpibind.mpibind_get_nthreads(self.__handle)
        return [raw[i] for i in range(self.ntasks)]

    @nthreads.setter
    def nthreads(self, var):
        rc = _libmpibind.mpibind_set_nthreads(self.__handle, var)
        if rc != 0:
            raise RuntimeError("mpibind_set_nthreads failed")

    @property
    def greedy(self):
        return _libmpibind.mpibind_get_greedy(self.__handle)

    @greedy.setter
    def greedy(self, var):
        rc = _libmpibind.mpibind_set_greedy(self.__handle, var)
        if rc != 0:
            raise RuntimeError("mpibind_set_greedy failed")

    @property
    def gpu_optim(self):
        return _libmpibind.mpibind_get_gpu_optim(self.__handle)

    @gpu_optim.setter
    def gpu_optim(self, var):
        rc = _libmpibind.mpibind_set_gpu_optim(self.__handle, var)
        if rc != 0:
            raise RuntimeError("mpibind_set_gpu_optim failed")

    @property
    def smt(self):
        return _libmpibind.mpibind_get_smt(self.__handle)

    @smt.setter
    def smt(self, var):
        rc = _libmpibind.mpibind_set_smt(self.__handle, var)
        if rc != 0:
            raise RuntimeError("mpibind_set_smt failed")

    @property
    def restrict_ids(self):
        return _ffi.string(_libmpibind.mpibind_get_restrict_ids(self.__handle)).decode('utf-8')

    @restrict_ids.setter
    def restrict_ids(self, var):
        self.__retrict_ids_p = _ffi.new('char[]', var.encode('utf-8'))
        rc = _libmpibind.mpibind_set_restrict_ids(self.__handle, self.__retrict_ids_p)
        if rc != 0:
            raise RuntimeError("mpibind_set_smt failed")

    @property
    def smt(self):
        return _libmpibind.mpibind_get_restrict_type(self.__handle)

    @smt.setter
    def smt(self, var):
        rc = _libmpibind.mpibind_set_restrict_type(self.__handle, var)
        if rc != 0:
            raise RuntimeError("mpibind_set_restrict_type failed")

    def get_gpus_ptask(self, taskid):
        ngpus = _ffi.new('int *')
        raw = _libmpibind.mpibind_get_gpus_ptask(self.__handle, taskid, ngpus)
        return [_ffi.string(raw[i]).decode('utf-8') for i in range(ngpus[0])]

    def mapping_ptask_snprint(self, taskid, size=None):
        if size == None:
            size = LONG_STR_SIZE
        
        buf = _ffi.new('char[]', size)
        written = _libmpibind.mpibind_mapping_ptask_snprint(buf, size, self.__handle, taskid)
        if written >= size:
            raise RuntimeError("mpibind_mapping_ptask_snprint buffer may be too small")
        return _ffi.string(buf).decode('utf-8')

    def mapping_snprint(self, size=None):
        if size == None:
            size = LONG_STR_SIZE
        
        buf = _ffi.new('char[]', size)
        written = _libmpibind.mpibind_mapping_snprint(buf, size, self.__handle)
        if written >= size:
            raise RuntimeError("mpibind_mapping_snprint buffer may be too small")
        return _ffi.string(buf).decode('utf-8')
    
    def set_gpu_ids(self, id_type):
        rc = _libmpibind.mpibind_set_gpu_ids(self.__handle, id_type)
        if rc != 0:
            raise RuntimeError("mpibind_set_gpu_ids failed")

    def set_env_vars(self, **kwargs):
        allowed = [
            'CUDA_VISIBLE_DEVICES',
            'ROCR_VISIBLE_DEVICES',
            'OMP_NUM_THREADS',
            'OMP_PLACES',
            'OMP_PROC_BIND'
        ]

        for key, value in kwargs.items():
            if key in allowed:
                os.environ[key] = value

        rc = _libmpibind.mpibind_set_env_vars(self.__handle)
        if rc != 0:
            raise RuntimeError("mpibind_set_env_vars failed")

    def env_vars_print(self):
        _libmpibind.mpibind_env_vars_print(self.__handle)

    def get_env_var_values(self, name):
        c_name = _ffi.new('char[]', name.encode('utf-8'))
        raw = _libmpibind.mpibind_get_env_var_values(self.__handle, c_name)
        return [_ffi.string(raw[i]).decode('utf-8') for i in range(self.ntasks)]
    
    def get_env_var_names(self):
        count = _ffi.new('int *')
        raw = _libmpibind.mpibind_get_env_var_names(self.__handle, count)
        return [_ffi.string(raw[i]).decode('utf-8') for i in range(count[0])]


if __name__ == "__main__":
    """Sandbox for testing"""
    print("These are the python bindings for mpibind\n-----------------------------------------")
    handle = MpibindHandle()
    handle.ntasks = 4
    handle.mpibind()
    print("Printing Mapping:\n")
    handle.mapping_print()
    print()
    handle.finalize()
